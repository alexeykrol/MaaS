# ROADMAP — План развития MaaS

Цель:

1. Сделать MaaS рабочим end-to-end.
2. Поверх него построить систему самообучения, которая:

   * генерирует тестовые диалоги,
   * извлекает из MaaS данные,
   * оценивает качество по метрикам,
   * меняет импакт-факторы через версионирование и rollback.

---

## Phase 1: Working MaaS (MVP) ✅

**Цель:** рабочий пайплайн, который отвечает на запросы с использованием памяти.

### Статус: 100% (12/12)

| Шаг | Название        | Статус | Суть                                                         |
| --- | --------------- | ------ | ------------------------------------------------------------ |
| 0   | Подготовка      | ✅      | Структура проекта, зависимости, Supabase                     |
| 1   | База данных     | ✅      | 6 таблиц, триггеры, seeds                                    |
| 2   | Test Runner     | ✅      | Engine + API + UI, mock-режим                                |
| 3   | Orchestrator    | ✅      | LISTEN/NOTIFY, маршрутизация                                 |
| 4   | Agent Stubs     | ✅      | Заглушки для всех агентов                                    |
| 5   | Logger          | ✅      | Логирование инференсов в `pipeline_runs` и связанные таблицы |
| 6   | Analyzer        | ✅      | Извлечение ключевых слов (LLM)                               |
| 7   | Assembler       | ✅      | Поиск памяти, сбор контекста                                 |
| 8   | Final Responder | ✅      | Генерация ответа (LLM)                                       |
| 9   | Archivist       | ✅      | Создание памяти после диалога                                |
| 10  | Assembler v2    | ✅      | Приоритизация, лимит токенов                                 |
| 11  | Полировка       | ✅      | Retry, error handling, cleanup                               |

Пайплайн:
`NEW → ANALYZING → ANALYZED → ASSEMBLING → READY → RESPONDING → COMPLETED`.

---

## Phase 2: Self-Learning System

**Цель:** поверх уже работающего MaaS построить цикл самообучения:

1. Эмулятор пользователя создаёт поток диалогов.
2. Код самообучения извлекает из таблиц MaaS данные и метрики.
3. Учитель анализирует результаты, формирует гипотезы и эксперименты.
4. Настройщик применяет/откатывает параметры.
5. Менеджер координирует циклы и даёт отчёты.

### Порядок реализации

| Шаг | Компонент         | Что делает                                                            |
| --- | ----------------- | --------------------------------------------------------------------- |
| 12  | **User Emulator** | Генерация диалогов и сценариев, которые прогоняются через MaaS        |
| 13  | **Sensor**        | Снимает данные с MaaS и складывает метрики в свою БД (история метрик) |
| 14  | **Teacher**       | Расчёт метрик качества, LLM-judge, дизайн/анализ экспериментов        |
| 15  | **Tuner**         | Версионирование параметров, применение и rollback                     |
| 16  | **Manager**       | Управление циклами, цели, отчёты, интерфейс для мета-пользователя     |

---

## Детализация шагов Phase 2

### Step 12: User Emulator

**Задача:** запустить постоянный поток тестовых запросов в MaaS, максимально похожий на реальных пользователей.

**Минимум:**

* форматы:

  * `sim_scenarios.json` — типовые проекты/темы;
  * `sim_personas.json` — профили синтетических пользователей;
* генерация thread’ов:

  * стартовый запрос с понятной целью;
  * последовательность уточнений/доп.вопросов в зависимости от ответов;
* интеграция:

  * эмулятор ходит в MaaS **через тот же entrypoint**, что и обычный клиент;
  * все запросы/ответы попадают в уже существующие `pipeline_runs` и связанный лог.

**Результат шага:**
MaaS получает устойчивый поток синтетических диалогов, по которым можно измерять качество.

---

### Step 13: Sensor (съём данных с MaaS)

**Задача:** снимать ключевые данные из работающего MaaS и сохранять их в отдельную БД модуля самообучения.

**Ключевые принципы:**

* MaaS сам по себе **не знает** о системе самообучения.
* При работе MaaS генерирует данные: запросы, ответы, статусы пайплайна, базовые метрики.
* **Sensor** — это отдельный процесс/модуль, который:

  * синхронно или асинхронно подписан на события MaaS (например, по `pipeline_runs`);
  * на каждом запуске пайплайна считывает нужные поля;
  * записывает их в свою схему (свои таблицы) внутри блока Self-Learning.

**Минимум:**

* завести отдельные таблицы сенсора (условно `sensor_events` или `selflearn_metrics`), которые хранят:

  * `pipeline_run_id` и привязку к пользователю/типу клиента (реальный/эмулятор);
  * временные метки старта/конца пайплайна;
  * рассчитанную латентность в мс;
  * счётчики токенов: `prompt_tokens`, `completion_tokens`;
  * базовые показатели по памяти: было ли найдено хоть что‑то, сколько memories поднято/использовано;
* реализовать код Sensor, который:

  * запускается вместе с MaaS (или подписан на его события);
  * при каждом завершённом `pipeline_run` делает insert в свои таблицы.

**Важно:**

* Sensor **ничего не анализирует** и не делает выводов — он только аккуратно фиксирует данные.
* Учитель читает метрики **из БД сенсора**, а не напрямую из рабочих таблиц MaaS.
* Даже если MaaS временно остановлен, у Учителя остаётся история метрик для анализа.

**Результат шага:**

Есть отдельное хранилище данных сенсора с историей метрик по всем запускам MaaS, на которое опирается Учитель и все последующие эксперименты.

---

### Step 14: Teacher

**Задача:** использовать данные из MaaS (логи + measurement-таблица), чтобы:

* считать метрики качества памяти;
* запускать LLM-judge для качественных оценок;
* формировать и анализировать эксперименты.

**Минимум:**

* модуль агрегирования метрик:

  * расчёт retrieval precision/recall и других метрик по `METRICS.md`;
* LLM-judge оркестратор:

  * промпты для оценки релевантности retrieved memories, использования контекста, галлюцинаций;
* описание эксперимента в явном формате (YAML/JSON):

  * baseline/variant,
  * какие параметры меняются,
  * какие метрики и дельты считаем;
* анализ результатов:

  * сбор выборок baseline vs variant,
  * расчёт дельт и простейших статистических критериев.

На этом шаге Teacher может ещё **ничего не менять сам**, а только выдавать текстовые/формальные рекомендации.

---

### Step 15: Tuner

**Задача:** дать системе возможность безопасно менять параметры в коде, без ручного редактирования конфигов.

**Минимум:**

* таблица `experiment_parameters`:

  * версия,
  * JSON с параметрами (retrieval, context, llm, archivist),
  * флаги активности,
  * причина изменения;
* функции:

  * `prepare_experiment` — создать версии параметров для baseline/variant;
  * `activate_parameter_version(version)` — переключить активную версию;
  * `rollback_parameters()` — откат на предыдущую рабочую версию;
* проверка диапазонов (guards) перед активацией:

  * для каждого параметра — допустимый диапазон/множество значений;
* audit-лог:

  * кто/что инициировал изменение (Teacher, ручной вызов),
  * ссылка на experiment_id.

**Результат шага:**
Teacher может выдавать изменения в машинном формате, а Tuner применяет их через версионирование и rollback.

---

### Step 16: Manager

**Задача:** объединить все компоненты в рабочий цикл самообучения и дать точку входа мета-пользователю.

**Минимум:**

* цикл запуска:

  * старт/остановка прогонов эмулятора;
  * запуск экспериментов (baseline vs variant);
  * триггеры micro/macro/deep-циклов по расписанию или по команде;
* управление целями:

  * хранение целей обучения и ограничений (primary-метрики + constraints);
  * связь экспериментов с конкретными целями;
* отчёты:

  * сводка по экспериментам (какие параметры тестировались, результат);
  * текущее активное состояние параметров;
  * история изменений и откатов;
* интерфейс к фронту:

  * API/слой, через который ты в UI задаёшь цели, запускаешь/останавливаешь эксперименты, утверждаешь критичные изменения.

---

## Критерии готовности Phase 2

Phase 2 можно считать рабочей, когда:

* [ ] User Emulator генерирует не меньше N (например, 100) диалогов за прогон, они проходят через обычный pipeline MaaS.
* [ ] По каждому pipeline_run автоматически записываются базовые метрики в отдельную таблицу.
* [ ] Teacher может:

  * собрать данные по эксперименту (baseline/variant),
  * посчитать ключевые метрики,
  * выдать формальный verdict и рекомендации.
* [ ] Tuner:

  * хранит версии параметров,
  * умеет включать новую версию и откатывать её по команде или по правилам деградации.
* [ ] Manager:

  * запускает/останавливает эксперименты,
  * хранит цели,
  * генерирует отчёты, которые можно читать как человек,
  * предоставляет API/слой для фронта.

---

## Справочные документы

| Документ                          | Содержание                                   |
| --------------------------------- | -------------------------------------------- |
| `BACKLOG.md`                      | Детальные чек-листы по шагам                 |
| `docs/selflearn/README.md`        | Общий обзор системы самообучения             |
| `docs/selflearn/USER_EMULATOR.md` | Спецификация User Emulator                   |
| `docs/selflearn/TEACHER.md`       | Спецификация Teacher                         |
| `docs/selflearn/TUNER.md`         | Спецификация Tuner                           |
| `docs/selflearn/MANAGER.md`       | Спецификация Manager                         |
| `IMPACTS.md`                      | Перечень и диапазоны импакт-факторов         |
| `METRICS.md`                      | Определения и формулы метрик качества памяти |
