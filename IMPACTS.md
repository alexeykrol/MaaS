# IMPACT_FACTORS — реальные импакт-факторы системы MaaS

## 0. Определение импакт-фактора в нашей конфигурации

Контекст:  
- Есть **один постановщик задач** (я).  
- Есть **один исполнитель** — кодовый агент (в IDE / VS Code).  
- Все изменения делаются через **команды агенту**: найти файл, изменить параметр, переписать промпт, обновить конфиг и т.д.

В этом контексте:

> **Импакт-фактор** — это конкретный артефакт системы (файл, промпт, конфигурация, параметр),  
> который:
> 1. **Находится под моим прямым контролем** (я могу дать команду агенту его изменить).
> 2. **Меняется явно и локально** (можно сформулировать команду вида: «измени X на Y в артефакте Z»).
> 3. **При изменении даёт измеримое влияние** на качество ответов системы MaaS.

Всё, что не удовлетворяет этим трём критериям, **не считается импакт-фактором**.
Логистический код, роутинг запросов и т.п. важны для функционирования, но если я не могу через них напрямую улучшить метрики качества, они здесь не описываются.

---

## 0.1. Архитектура записи импакт-факторов

MaaS — **изолированная система**. Она не знает о существовании системы самообучения и не читает из её таблиц.

Запись оптимизированных значений происходит через **Tuner**:

```
Self-Learning (анализ метрик)
        │
        │ Teacher формирует рекомендации
        ▼
   experiment_parameters (версионирование в Self-Learning)
        │
        │ Tuner активирует версию
        ▼
   Таблицы MaaS (прямая запись)
   ├── impact_values (числовые параметры)
   └── system_prompts (промпты агентов)
```

**Tuner** — код, который:
- Хранит версии параметров в `experiment_parameters` (Self-Learning)
- При активации версии записывает значения НАПРЯМУЮ в таблицы MaaS
- Это как «веса» для модели — результат обучения записывается в систему

**Важно:** MaaS ничего не читает из `experiment_parameters`. Tuner сам записывает оптимизированные значения в таблицы MaaS (`impact_values`, `system_prompts`).

---

## 0.2. Таблица impact_values (MaaS)

Все числовые/строковые параметры хранятся в одной таблице:

```sql
CREATE TABLE impact_values (
  key VARCHAR(50) PRIMARY KEY,
  value JSONB NOT NULL,
  description TEXT,
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

### Список ключей

| Ключ | Тип | Описание | Секция |
|------|-----|----------|--------|
| `retrieval_strategy` | string | 'tags' / 'semantic' / 'hybrid' | §1 |
| `use_semantic_search` | boolean | включить семантический поиск | §1 |
| `top_k` | integer | количество memories | §4 |
| `min_score` | float | минимальный порог релевантности | §4 |
| `relevance_weight` | float | вес релевантности (0-1) | §7 |
| `recency_weight` | float | вес свежести (0-1) | §7 |
| `max_context_tokens` | integer | лимит токенов контекста | §8 |
| `llm_model_default` | string | модель по умолчанию | §6 |
| `llm_model_complex` | string | модель для сложных запросов | §6 |
| `temperature` | float | temperature для responder | §9 |

### Промпты (таблица system_prompts)

| prompt_type | Описание | Секция |
|-------------|----------|--------|
| `analyzer` | Промпт для извлечения ключевых слов | §2 |
| `archivist` | Промпт для генерации тегов | §3 |
| `responder` | Промпт для финального ответа | §5 |

### Как MaaS читает параметры

```typescript
// src/utils/config.ts
async function getImpact(key: string): Promise<any> {
  const { data } = await supabase
    .from('impact_values')
    .select('value')
    .eq('key', key)
    .single();
  return data?.value;
}

// Использование в агентах:
const topK = await getImpact('top_k');  // 3
const strategy = await getImpact('retrieval_strategy');  // 'hybrid'
```

Ниже — перечень импакт-факторов **в порядке убывания влияния на качество**.

---

## 1. Retrieval Strategy — конфигурация стратегии поиска памяти

### 1.1. Что именно является импакт-фактором

**Артефакт:** конфигурация retrieval-контура (условно: `retrieval_config`).  
В ней задаются, как минимум:

- режимы поиска:
  - использование только тегов;
  - использование только семантического поиска (embeddings);
  - гибрид (теги + семантика);
- параметры стратегии ранжирования (какие поля участвуют в расчёте «релевантности»).

Это **набор конкретных полей в конфиге**, которые кодовый агент может найти и изменить по команде.

### 1.2. Механизм влияния

Retrieval Strategy определяет **список кандидатов-воспоминаний**, которые вообще попадут в контекст ответа.

Цепочка влияния:

1. Пользовательский запрос → выделяются ключевые сущности/смыслы.
2. Retrieval-контур по конфигу выбирает способ поиска:
   - только совпадения по тегам;
   - только семантическое сходство;
   - комбинация.
3. На основе этого набора правил формируется список кандидатов.
4. Всё остальное (какой LLM, какой system prompt) работает уже **поверх этого списка**.

Если стратегию настроить неправильно, в контекст попадает:
- нерелевантная память;
- или ничего полезного.

### 1.3. На какие метрики влияет

- **Retrieval Precision** — доля поднятых воспоминаний, которые действительно относятся к запросу.
- **Retrieval Recall** — доля всех нужных воспоминаний, которые мы вообще поднимаем.
- **Hallucination Rate** — косвенно (если контекста нет или он мусорный → модель чаще придумывает).
- **Subjective “ он меня помнит / не помнит ”** — как ощущается работа памяти.

### 1.4. Целевой артефакт MaaS (куда Tuner записывает)

**Таблица:** `impact_values`
**Ключи:** `retrieval_strategy`, `use_semantic_search`

```sql
UPDATE impact_values SET value = '"hybrid"' WHERE key = 'retrieval_strategy';
UPDATE impact_values SET value = 'true' WHERE key = 'use_semantic_search';
```

**Tuner записывает:** UPDATE значений в таблице `impact_values`.

### 1.5. Примеры конкретных изменений

Что можно попросить сделать кодовый агент:

- Найти конфигурацию retrieval-контура и:
  - добавить/изменить режим `strategy` (например, с `tags` на `hybrid`);
  - включить или отключить семантический поиск;
  - явно указать, что при поиске по тегам нужно учитывать только `semantic_tags`, а не все поля.
- В конфиге ранжирования:
  - задать список полей, которые участвуют в расчёте score;
  - убрать из ранжирования поля, которые создают шум.

Все изменения формулируются в стиле:
**«Найди конфиг retrieval, параметр X, измени его значение с A на B, опиши, как это повлияет на Precision/Recall»**.

---

## 2. Keyword Extraction — настройки извлечения ключевых смыслов из запроса

### 2.1. Что является импакт-фактором

**Артефакты:**

1. Инструкция / промпт для компонента, который извлекает ключевые слова/понятия из запроса  
   (условно: `keyword_extractor_prompt.md`).
2. Конфигурация фильтрации и нормализации ключевых слов  
   (условно: `keyword_config` — список стоп-слов, минимальная длина, списки доменных терминов).

### 2.2. Механизм влияния

Keyword Extraction управляет тем, какие **термины и сущности** будут использоваться как вход в retrieval-контур.

Цепочка:

1. Исходный пользовательский запрос подаётся в компонент извлечения ключей.
2. На основе промпта и конфигурации он выдаёт список терминов.
3. Эти термины используются при поиске по тегам / семантическом поиске.
4. Неверные или шумные ключи → поисковый запрос «смотрит не туда».

### 2.3. Метрики

- **Hit Rate** — доля запросов, для которых вообще нашлись релевантные воспоминания.
- **Retrieval Precision / Recall** — через качество термов.
- **Ошибка “не нашёл, хотя в памяти есть”** — напрямую зависит от того, насколько правильно были извлечены ключи.

### 2.4. Целевой артефакт MaaS (куда Tuner записывает)

**Таблица:** `system_prompts`
**Условие:** `prompt_type = 'analyzer'`

```sql
UPDATE system_prompts
SET content = '...'
WHERE prompt_type = 'analyzer' AND is_active = true;
```

**Tuner записывает:** новый текст промпта для Analyzer агента.

### 2.5. Конкретные изменения

Команды для кодового агента:

- Найти промпт для keyword-extractor и:
  - добавить явное требование выделять:
    - предметную область;
    - сущности (языки, люди, проекты);
    - тип действия (вопрос, решение, план).
  - удалить размытые формулировки («найди важные слова») и заменить на конкретные правила.
- В конфиге:
  - задать список стоп-слов (служебные слова, местоимения и т.п.);
  - задать минимальную длину терма;
  - добавить доменный словарь (python, js, supabase, и т.д.), который никогда не фильтруется.

---

## 3. Archivist Tagging — промпт и правила генерации тегов при записи памяти

### 3.1. Что является импакт-фактором

**Артефакты:**

1. System prompt / инструкция для ассистента-архивариуса (условно: `archivist_system_prompt.md`).
2. Правила нормализации тегов (словарь допустимых тегов, маппинг синонимов на каноническую форму).

### 3.2. Механизм влияния

Archivist формирует **структурированное представление памяти** в момент записи:

- краткое описание (summary),
- список тегов.

Если теги:

- слишком общие → память почти не поднимается;
- слишком шумные → память поднимается по нерелевантным запросам;
- непоследовательные (много вариантов одного и того же) → падает эффективность поиска по тегам.

### 3.3. Метрики

- **Recall в долгую** — через некоторое время: как часто нужные воспоминания вообще находятся.
- **Доля “мертвых” записей** — записей, которые почти никогда не поднимаются.
- **Стабильность поведения памяти по мере роста базы** — насколько деградирует поиск при увеличении количества записей.

### 3.4. Целевой артефакт MaaS (куда Tuner записывает)

**Таблица:** `system_prompts`
**Условие:** `prompt_type = 'archivist'`

```sql
UPDATE system_prompts
SET content = '...'
WHERE prompt_type = 'archivist' AND is_active = true;
```

**Tuner записывает:** новый текст промпта для Archivist агента.

### 3.5. Конкретные изменения

Команды для кодового агента:

- Найти system prompt Archivist и:
  - удалить общие фразы вроде «добавь теги»;
  - добавить явные правила:
    - всегда включать в теги:
      - конкретные сущности (имена технологий, людей, проектов);
      - тип отношения (предпочитает, отказывается, выбрал, сомневается);
      - домен (карьера, здоровье, проекты и т.п.);
    - запрещать теги вроде `conversation`, `user`, `chat`.
- Создать/обновить словарь тегов:
  - завести канонические формы (например, `python`, `favorite_language`);
  - задать маппинг синонимов на эти формы (например, `favourite` → `favorite`, `fav` → `favorite`).

---

## 4. top_k и пороги отбора — параметры размера выборки памяти

### 4.1. Что является импакт-фактором

**Артефакты:**

1. Параметр `top_k` в конфигурации retrieval-контура.  
2. Параметры порогов по score (например, минимальная релевантность для включения в контекст).

### 4.2. Механизм влияния

Эти параметры определяют:

- сколько кандидатов-воспоминаний из результатов поиска попадут в итоговый контекст;
- попадут ли туда пограничные по релевантности записи.

Слишком маленькие значения → высокая точность, риск пропустить нужное.  
Слишком большие значения → много шума, выше риск неверных выводов модели.

### 4.3. Метрики

- **Precision vs Recall** в retrieval.
- **Доля ответов “слишком общих”** — когда контекста мало.
- **Доля ответов “перегруженных”** — когда модель упоминает лишние детали и приписывает пользователю то, чего он не говорил.

### 4.4. Целевой артефакт MaaS (куда Tuner записывает)

**Таблица:** `impact_values`
**Ключи:** `top_k`, `min_score`

```sql
UPDATE impact_values SET value = '3' WHERE key = 'top_k';
UPDATE impact_values SET value = '0.5' WHERE key = 'min_score';
```

**Tuner записывает:** UPDATE значений в таблице `impact_values`.

### 4.5. Конкретные изменения

Команды для кодового агента:

- Найти конфигурацию параметров retrieval и:
  - задать конкретное значение `top_k` (например, 2 или 3);
  - добавить порог score, ниже которого записи не включаются;
  - при необходимости сделать значение `top_k` зависимым от уверенности (в конфиге описать правила: при высоком score — `top_k=2`, при среднем — `top_k=3`).

---

## 5. Responder System Prompt — инструкция основному ассистенту

### 5.1. Что является импакт-фактором

**Артефакт:** system prompt ассистента, который формирует финальный ответ пользователю  
(условно: `responder_system_prompt.md`).

Это текст, который определяет:

- как ассистент должен относиться к памяти;
- имеет ли он право “додумывать”, когда контекста нет;
- как он должен обозначать отсутствие информации.

### 5.2. Механизм влияния

System prompt управляет:

- честностью по отношению к памяти (говорить “не знаю” vs выдумывать);
- тем, как ассистент использует контекст:
  - опирается на него как на обязательную основу;
  - или воспринимает как необязательную подсказку.

Даже при хорошем retrieval, неправильный system prompt может заставить модель игнорировать контекст или заполнить пробелы фантазиями.

### 5.3. Метрики

- **Hallucination Rate** — частота выдуманных фактов о пользователе.
- **Доля ответов “не знаю, данных нет” там, где это корректно.**
- **Уровень соответствия памяти** — насколько ответы действительно опираются на поднятые воспоминания.

### 5.4. Целевой артефакт MaaS (куда Tuner записывает)

**Таблица:** `system_prompts`
**Условие:** `prompt_type = 'responder'`

```sql
UPDATE system_prompts
SET content = '...'
WHERE prompt_type = 'responder' AND is_active = true;
```

**Tuner записывает:** новый текст промпта для Final Responder агента.

### 5.5. Конкретные изменения

Команды для кодового агента:

- Найти system prompt Responder и:
  - удалить формулировки вида «ты отлично помнишь пользователя»;
  - явно добавить правила:
    - использовать только переданный контекст для утверждений о пользователе;
    - при отсутствии релевантного контекста:
      - либо отвечать "нет данных в памяти";
      - либо отвечать общими соображениями, **но явно отделять их от памяти**;
    - никогда не приписывать пользователю факты, которых нет в контексте.
- Структурировать prompt:
  - блок про работу с памятью;
  - блок про общий тон;
  - блок про обработку случаев "контекста нет".

---

## 6. LLM Model Selection — выбор модели для разных задач

### 6.1. Что является импакт-фактором

**Артефакты:**

1. Конфигурация моделей (условно: `llm_config`), где описано:
   - какие модели доступны;
   - какие используются по умолчанию.
2. Правила маршрутизации запросов к моделям:
   - когда использовать «маленькую» модель;
   - когда — «большую».

### 6.2. Механизм влияния

Модель влияет на:

- способность правильно интерпретировать сложные контексты;
- аккуратность следования инструкциям в system prompt;
- устойчивость к неоднозначным формулировкам.

При равном контексте:

- слабая модель чаще ошибается в сложных задачах;
- сильная модель стоит дороже и работает медленнее.

### 6.3. Метрики

- **Accuracy на сложных сценариях** (аналитика, многослойные вопросы).
- **Время ответа**.
- **Стоимость токенов**.

### 6.4. Целевой артефакт MaaS (куда Tuner записывает)

**Таблица:** `impact_values`
**Ключи:** `llm_model_default`, `llm_model_complex`

```sql
UPDATE impact_values SET value = '"gpt-4o-mini"' WHERE key = 'llm_model_default';
UPDATE impact_values SET value = '"gpt-4o"' WHERE key = 'llm_model_complex';
```

**Tuner записывает:** UPDATE значений в таблице `impact_values`.

### 6.5. Конкретные изменения

Команды для кодового агента:

- Найти конфигурацию моделей и:
  - задать модель по умолчанию для простых запросов (например, "mini");
  - задать модель для сложных запросов (например, "4o").
- Описать в конфиге правило выбора модели:
  - по длине запроса;
  - по наличию в запросе слов типа "проанализируй", "сравни", "дай стратегию" и т.п.;
  - по размеру поднятого контекста (если много памяти → использовать более сильную модель).

---

## 7. Relevance / Recency Weights — параметры вычисления итогового score записи

### 7.1. Что является импакт-фактором

**Артефакт:** конфигурация расчёта итоговой релевантности памяти  
(условно: `scoring_config`), где заданы веса:

- `relevance_weight` — насколько важен смысловой score;
- `recency_weight` — насколько важна свежесть (`created_at`, `updated_at`).

### 7.2. Механизм влияния

Эти веса определяют, какие записи будут выше в итоговом ранжировании:

- более релевантные по смыслу;
- более свежие.

От них зависит, будут ли устаревшие, но хорошо помеченные записи подниматься выше свежих, или наоборот.

### 7.3. Метрики

- **Корректность временных ответов** — насколько часто система опирается на актуальные решения, а не на старые.
- **Стабильность фактов** — не “перепрыгивает” ли система между разными историческими версиями предпочтений пользователя.

### 7.4. Целевой артефакт MaaS (куда Tuner записывает)

**Таблица:** `impact_values`
**Ключи:** `relevance_weight`, `recency_weight`

```sql
UPDATE impact_values SET value = '0.7' WHERE key = 'relevance_weight';
UPDATE impact_values SET value = '0.3' WHERE key = 'recency_weight';
```

**Tuner записывает:** UPDATE значений в таблице `impact_values`.

### 7.5. Конкретные изменения

Команды для кодового агента:

- Найти конфиг scoring и:
  - увеличить или уменьшить `recency_weight`, если нужно сильнее/слабее учитывать свежесть;
  - поднять `relevance_weight`, если наблюдается опора на более свежий, но менее релевантный мусор.
- Задать предустановленные профили:
  - для запросов о фактах (email, имя) — высокий `relevance_weight`;
  - для запросов о недавних решениях — высокий `recency_weight`.

---

## 8. Max Context Tokens — лимиты на объём контекста

### 8.1. Что является импакт-фактором

**Артефакт:** конфиг токен-лимитов (условно: `context_budget_config`):

- общий лимит токенов;
- лимиты для:
  - system prompt;
  - свежих сообщений диалога;
  - блока памяти (retrieved memories);
  - технического буфера.

### 8.2. Механизм влияния

Эти лимиты определяют:

- сколько памяти можно включить в один запрос к модели;
- какой объём текущего диалога сохраняется;
- сколько места остаётся для ответа.

При маленьком лимите контекста память режется; при слишком большом — растут стоимость и время.

### 8.3. Метрики

- **Context Completeness** — насколько часто в контекст не помещаются все релевантные воспоминания.
- **Стоимость и латентность** — прямое следствие размера контекста.
- **Когнитивная перегрузка модели** — непрямой эффект при слишком больших контекстах.

### 8.4. Целевой артефакт MaaS (куда Tuner записывает)

**Таблица:** `impact_values`
**Ключи:** `max_context_tokens`

```sql
UPDATE impact_values SET value = '4000' WHERE key = 'max_context_tokens';
```

**Tuner записывает:** UPDATE значений в таблице `impact_values`.

### 8.5. Конкретные изменения

Команды для кодового агента:

- Найти конфиг токен-бюджета и:
  - задать конкретный лимит на блок памяти (например, сколько примерно слов/записей можно включать);
  - изменить приоритет: что обрезать первым — старые сообщения диалога или лишние воспоминания.
- Описать правила усечения:
  - сначала удалять наименее релевантные записи;
  - затем старые фрагменты диалога.

---

## 9. Temperature — параметр вариативности ответов

### 9.1. Что является импакт-фактором

**Артефакт:** конфигурация генерации ответов (условно: `generation_config`), в которой есть:

- значение `temperature` для ассистента Responder (и, при необходимости, для других ассистентов).

### 9.2. Механизм влияния

Temperature определяет:

- насколько ответы будут однообразными/стабильными;
- насколько модель будет склонна к вариативным формулировкам.

Для системы памяти этот параметр **влияет не на фактологическую точность памяти, а на форму и риск “додуманных” деталей**.

### 9.3. Метрики

- **Consistency** — насколько ответы одинаковы при одинаковом контексте.
- **Риск косметических “украшательств”** — добавление несущественных деталей.

### 9.4. Целевой артефакт MaaS (куда Tuner записывает)

**Таблица:** `impact_values`
**Ключи:** `temperature`

```sql
UPDATE impact_values SET value = '0.3' WHERE key = 'temperature';
```

**Tuner записывает:** UPDATE значений в таблице `impact_values`.

### 9.5. Конкретные изменения

Команды для кодового агента:

- Найти конфиг генерации и:
  - задать низкую или умеренную температуру для ответов, основанных на памяти (например, 0.2–0.4);
  - при необходимости задать отдельную температуру для креативных задач (генерация идей, текстов).

---

## 10. Сводка по приоритетам

В терминах **реальных артефактов и команд для кодового агента** приоритеты такие:

1. **Retrieval Strategy (`retrieval_config`)**  
   Определяет, как вообще ищем память.

2. **Keyword Extraction (`keyword_extractor_prompt`, `keyword_config`)**  
   Определяет, по каким смыслам ищем.

3. **Archivist Tagging (`archivist_system_prompt`, словарь тегов)**  
   Определяет, как память записывается и помечается.

4. **top_k и пороги (`retrieval_config`)**  
   Определяют объём и качество контекста.

5. **Responder System Prompt (`responder_system_prompt`)**  
   Определяет отношение к памяти и честность.

6. **LLM Model Selection (`llm_config`)**  
   Определяет, какая модель решает какую задачу.

7. **Relevance / Recency Weights (`scoring_config`)**  
   Определяют приоритет свежести vs смысловой близости.

8. **Max Context Tokens (`context_budget_config`)**  
   Определяют, сколько памяти вообще можно подать.

9. **Temperature (`generation_config`)**  
   Определяет вариативность формулировок.

Каждый импакт-фактор в этом списке — это **конкретный конфиг / файл / промпт**, который можно адресовать кодовому агенту явной командой.  
Если нельзя сформулировать команду вида:

> «Найди артефакт X. В нём измени параметр/инструкцию Y с значения A на значение B.»

— это не входит в этот документ.

---

## 11. Связь с METRICS.md

Этот документ определяет **выходной интерфейс** системы самообучения:

```
METRICS.md (что Sensor читает из MaaS)
        │
        ▼
   sensor_events → Teacher → рекомендации
        │
        ▼
   experiment_parameters → Tuner → активация
        │
        ▼
IMPACTS.md (куда Tuner пишет в MaaS)
```

| Документ | Роль | Направление данных |
|----------|------|-------------------|
| **METRICS.md** | Что наблюдаем | MaaS → Self-Learning |
| **IMPACTS.md** | Что меняем | Self-Learning → MaaS |

См. также: [METRICS.md](./METRICS.md), [docs/selflearn/README.md](./docs/selflearn/README.md)

---

*Последнее обновление: 2025-11-26*
