Первый принцип — память должна быть анизотропной.
Речь идёт не о теории человека, а об архитектуре памяти ИИ-ассистента, которая ведёт себя похоже на человеческую (а местами — рациональнее и прозрачнее).

⸻

1. Анизотропия памяти: актуальность, время и целостность

Анизотропия памяти означает, что не все воспоминания (эпизоды) равны:
то, что более актуально сейчас, притягивает больше внимания и восстанавливается быстрее и полнее.

В человеческой метафоре: человек живёт в настоящем и помнит главным образом то, что ему нужно для немедленной реакции.
В архитектуре ИИ-ассистента это означает:
	•	есть зона максимальной актуальности, в которой информация хранится детально и доступна мгновенно;
	•	есть более дальние зоны, где информация хранится в упакованном виде и требует времени/ресурса на восстановление.

Из разной степени актуальности вытекает анизотропия:
	•	лучше всего восстанавливается что-то недавнее и связанное с текущими задачами пользователя;
	•	более давние эпизоды всплывают медленнее и более фрагментарно;
	•	по мере обращения к ним они могут снова становиться актуальными и «распакованными».

⸻

2. Атом памяти: что именно мы храним

Чтобы это можно было реализовать, нужно определить, что именно является единицей хранения.
В архитектуре ИИ-ассистента атом памяти — это эпизод.

Эпизод — это не одно сообщение, а связаный блок взаимодействия вокруг одной темы/задачи/контекста.
Например: «обсуждение архитектуры памяти», «разбор налогов за 2024 год», «помощь с конкретным багом в коде».

Каждый эпизод в памяти ассистента — это структура с полями:
	•	временная метка (когда это происходило);
	•	краткий заголовок (о чём эпизод);
	•	сжатое резюме (N токенов, короткое описание сути);
	•	эмбеддинг (векторное представление смысла эпизода);
	•	ссылки на «сырые» логи (полные тексты сообщений), если они ещё доступны;
	•	служебные метрики:
	•	сколько раз эпизод поднимался и использовался;
	•	когда в последний раз к нему обращались;
	•	есть ли у него статус «важное / закреплённое»;
	•	оценка полезности при прошлых обращениях.

Именно на уровне эпизодов работают упаковка, распаковка, поиск и промоушен.

⸻

3. Временная шкала и актуальное окно

Можно представить, что у памяти ассистента есть временная шкала и несколько «слоёв»:
	1.	Актуальное окно.
Условно — последние дни/недели, когда пользователь активно решает ограниченный набор задач.
В этом окне эпизоды хранятся в максимально «распакованном» виде:
	•	резюме достаточно подробные;
	•	ссылки на сырые логи активны;
	•	доступ быстрый и массовый — ассистент может легко подтянуть сразу весь связанный контекст.
	2.	Промежуточные слои (месяцы).
Здесь эпизоды уже более компактные:
	•	хранится хорошее резюме + эмбеддинг;
	•	сырые логи либо лежат в холодном хранилище, либо частично удалены;
	•	доступ возможен, но требует выбора: какие эпизоды стоит поднимать.
	3.	Дальние слои (годы).
Здесь всё хранится в сильно упакованном виде, в стандартном формате:
	•	короткое резюме «о чём это»;
	•	эмбеддинг для поиска по смыслу;
	•	сырые логи могут отсутствовать полностью.

Важно: время само по себе не убивает память.
У старого эпизода может быть высокий приоритет, если он:
	•	часто используется;
	•	помечен пользователем как важный («запомни навсегда», «это мой принцип/правило»);
	•	критичен для идентичности пользователя (био, ключевые настройки, долгосрочные проекты).

Но по умолчанию актуальность убывает с временем, если эпизод не используется и не закреплён.

⸻

4. Функция актуальности / приоритета

Чтобы анизотропия стала не метафорой, а алгоритмом, у каждого эпизода есть числовой приоритет P.

Он может зависеть от:
	•	Recency — давность (когда эпизод в последний раз использовался);
	•	Frequency — частота (сколько раз к нему обращались);
	•	Explicit importance — явные сигналы пользователя:
	•	фразы типа «запомни это», «это важно», «это про меня всегда»;
	•	закрепление в интерфейсе («pin», «favorites»);
	•	Task relevance — насколько часто эпизод всплывает в похожих задачах (по эмбеддингам).

Формула может быть любой, но концепция такая:
	•	эпизоды с P > T₁ находятся в актуальном окне;
	•	эпизоды с T₂ < P ≤ T₁ живут в промежуточных слоях;
	•	эпизоды с P ≤ T₂ считаются глубоко архивными и максимально упакованы.

Так ассистент всегда знает:
	•	что держать «на кончиках пальцев»;
	•	что хранить как быстрый индекс «о чём это было»;
	•	что можно выкинуть/объединить/дополнительно сжать при нехватке ресурсов.

⸻

5. Механизм вспоминания и промоушена

Когда ассистенту нужно что-то вспомнить, он не читает сразу всё прошлое.
Он делает это по слоям:
	1.	Запрос → поиск по актуальному окну.
Сначала он смотрит на эпизоды с самым высоким приоритетом:
	•	по эмбеддингам;
	•	по ключевым словам;
	•	по явным связям с текущей задачей.
	2.	Если в актуальном окне недостаточно — расширение в глубину.
Тогда запускается поиск по более глубоким слоям:
	•	сначала по промежуточным;
	•	потом по дальним архивным.
	3.	Промоушен.
Если какой-то старый эпизод оказался полезен:
	•	его приоритет увеличивается;
	•	он может быть поднят в актуальное окно;
	•	при необходимости его можно распаковать: расширить резюме, подтянуть логи, дорезюмировать.

Таким образом, дальняя память существует не как мёртвый архив, а как набор кандидатов на возвращение в зону актуального.
Старое «полугодовое» событие, если оно снова становится важным, переезжает в актуальный слой и начинает вести себя как свежий контекст.

⸻

6. Жизненный цикл эпизода: запись → упаковка → архив → распаковка

Важно описать не только чтение (вспоминание), но и запись.

6.1. Формирование эпизода (write-path)

Новый эпизод формируется, когда:
	•	начинается новая задача/тема (по смене семантики диалога);
	•	или истекает определённое время активности (например, сессия > N минут);
	•	или пользователь явно задаёт рамку («давай новый проект», «запусти новый диалог про…»).

На этом шаге:
	•	собираются сырые логи сообщений;
	•	создаётся первоначальное резюме;
	•	рассчитывается эмбеддинг;
	•	эпизоду присваивается стартовый приоритет (высокий, так как он только что был в фокусе).

6.2. Упаковка

Через какое-то время после завершения активной фазы:
	•	сырые логи могут быть частично или полностью свернуты (зависит от политики и ресурсов);
	•	модель один раз проходит по диалогу и делает более компактное резюме;
	•	при необходимости выделяются под-резюме (подэпизоды) по ключевым подтемам.

Цель упаковки — оставить достаточно информации, чтобы:
	•	быстро понять, «о чём это было»;
	•	иметь возможность при необходимости восстановить или реконструировать детали.

6.3. Архивирование

Когда эпизод давно не использовался и его приоритет упал ниже порога:
	•	он переходит в стандартный архивный формат (короткое резюме + эмбеддинг);
	•	сырые логи могут быть удалены или перенесены в холодное, дешёвое хранилище;
	•	дополнительные украшения (подробные связи, метаданные) могут быть сжаты или объединены.

6.4. Распаковка и возвращение в актуальное

Если впоследствии контекст запроса пользователя указывает на этот эпизод:
	•	по эмбеддингу и ключевым словам он находится в архиве;
	•	при обращении к нему его приоритет растёт;
	•	если он начинает часто всплывать, он возвращается в актуальное окно;
	•	при этом можно:
	•	подтянуть холодные логи (если они есть),
	•	дополнить резюме,
	•	создать новое, более подробное резюме под текущую задачу.

Так возникает эффект: «старое вспоминается и снова становится живым».

⸻

7. Ограничения ресурсов и политика очистки

Память ассистента — ресурс с ограничением по объёму и стоимости доступа (деньги, время, токены).

Поэтому архитектура подразумевает:
	•	Жёсткий лимит актуального слоя:
	•	ограниченное число эпизодов;
	•	ограничение по суммарному объёму токенов в резюме;
	•	при переполнении самые низкоприоритетные эпизоды принудительно упаковываются или выталкиваются в архив.
	•	Бюджет на хранение сырых логов:
	•	далеко не все сессии имеют смысл хранить в полном виде;
	•	часть логов может удаляться после того, как по ним построено резюме.
	•	Долгосрочное хранение в дешёвой форме:
	•	в глубоком архиве остаются только эмбеддинги + короткие резюме;
	•	приоритетное — то, что либо часто используется, либо помечено пользователем.

Так анизотропия становится не только когнитивной метафорой, но и способом оптимизации затрат.

⸻

8. Ручные «якоря» и постоянная память

Часто пользователю нужно нечто вроде: «запомни это навсегда».
Это то, что в человеческой психике эквивалентно базовым установкам, биографии, принципам.

В архитектуре памяти ассистента для этого нужны якорные эпизоды:
	•	они помечаются специальным флагом;
	•	их приоритет не может упасть ниже определённого уровня, как бы давно они ни использовались;
	•	политика очистки к ним применима только в очень мягком варианте (сжатие логов, но не удаление смысла);
	•	это:
	•	профиль пользователя,
	•	его устойчивые предпочтения и правила,
	•	долговременные проекты,
	•	системные инструкции уровня «как со мной разговаривать».

Таким образом, помимо «текущего окна» и «архива», есть слой постоянной памяти, который лежит ближе всего к ядру ассистента.

⸻

9. Аналогия с книгами — уже как поведение ассистента

Аналогия с чтением книг помогает увидеть, как это выглядит в пользовании.
	•	Сейчас ассистент «читает» книгу — ведёт сессию, решает задачу.
Эта книга (эпизод) в зоне актуального:
	•	он помнит её структуру, детали, исходные формулировки.
	•	Есть книги, которые были «прочитаны» две недели, месяц, год назад — старые сессии и проекты.
Чем дальше по времени и ниже актуальность, тем больше они хранятся как:
	•	короткие конспекты,
	•	тематические теги,
	•	эмбеддинги, по которым можно найти «что это было».

Если какая-то «книга» снова становится интересной:
	•	пользователь возвращается к теме;
	•	ассистент находит соответствующий эпизод по смыслу;
	•	поднимает его в актуальное окно;
	•	при необходимости догружает детали или пересобирает резюме под текущую задачу.

Если же при проверке эпизода выясняется, что это не нужно сейчас:
	•	ассистент кратко фиксирует: «о чём это»;
	•	приоритет эпизода может почти не измениться;
	•	и он остаётся в архиве просто как индекс прошлого опыта.

⸻

10. Итог: как эта архитектура работает в живой системе

Если собрать все идеи вместе, получается такая модель памяти ИИ-ассистента:
	1.	Память анизотропна:
качество и скорость доступа зависят от актуальности и частоты использования, а не только от времени.
	2.	Атом памяти — эпизод:
связанный блок взаимодействия с резюме, эмбеддингом, логами и метриками.
	3.	Есть актуальное окно и несколько слоёв дальних воспоминаний:
чем дальше и менее актуально, тем плотнее упаковка.
	4.	У каждого эпизода есть числовой приоритет:
он задаётся функцией recency / frequency / важности / релевантности задачам.
	5.	Жизненный цикл эпизода:
	•	формирование из сырого диалога,
	•	упаковка,
	•	архивирование,
	•	возможная распаковка и промоушен обратно в актуальное окно.
	6.	Есть ресурсные ограничения:
память управляется как ресурс с бюджетом; слабые, давно неиспользуемые эпизоды ужимаются или удаляются.
	7.	Есть слой якорей:
эпизоды, явно закреплённые пользователем или системой, живут дольше и глубже вшиваются в модель поведения ассистента.

Такое устройство позволяет памяти ассистента:
	•	вести себя узнаваемо по-человечески (актуальное помнится лучше, далёкое вспоминается по запросу);
	•	но при этом быть более рациональной и управляемой:
явные приоритеты, ясные политики хранения, прозрачные критерии того, что поднимается в фокус, а что остается в архиве.