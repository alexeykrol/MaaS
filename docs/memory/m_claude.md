# Архитектура памяти AI-ассистента: принцип анизотропии

## Философия подхода

Память должна работать так, как работает человеческая — а возможно, и лучше. Человек живёт в настоящем и вспоминает в первую очередь то, что ему нужно для немедленной реакции. То, что находится в фокусе внимания сейчас, помнится «на кончиках пальцев», детально, со всеми взаимосвязями. Всё остальное — размыто, фрагментарно, требует усилий для восстановления.

Это не баг, а фича. Память как алгоритм работает рационально: у неё есть определённые последовательности восстановления блоков информации, и эта архитектура оптимизирована под реальные потребности. Нет смысла держать всё одинаково доступным — это и невозможно, и не нужно.

Отсюда ключевой принцип: **память анизотропна**. Разная степень актуальности порождает разный формат хранения, разную скорость доступа, разную полноту восстановления.

## Два фундаментальных параметра

### Актуальность

Насколько информация востребована прямо сейчас. Это динамический параметр — он меняется в зависимости от текущего контекста разговора, от того, какие проблемы человек решает в данный момент.

Человек в текущий момент всегда решает ограниченный набор проблем. Если проблема не решена — она остаётся актуальной, соответствующие воспоминания держатся «наготове». Если проблема решена — связанная информация постепенно теряет актуальность и мигрирует в более глубокие слои.

### Целостность

Полнота сохранённых связей между элементами воспоминания. Более актуальные воспоминания имеют более широкий связанный контекст — что-то вроде scale-free сетей связанных понятий. Это обеспечивает целостность: можно быстро вытащить весь контекст и представить его.

Менее актуальные воспоминания — это скорее набор фрагментов: отдельные понятия, ключевые слова, обрывки. Связи между ними ослаблены или утрачены.

**Ключевая зависимость:** актуальность и целостность взаимосвязаны. Чем выше актуальность — тем выше целостность. Чем дальше в прошлое — тем более фрагментарно хранение.

## Архитектура хранения: три слоя

### Слой 1: Горячий (0–14 дней)

**Характеристики хранения:**
- Полный контекст со всеми связями между элементами
- Высокая целостность — воспоминания образуют связную сеть
- Быстрый одновременный доступ ко всему контексту

**Оптимизация:**
- Симметричный поиск в любом направлении (от любого элемента к любому)
- Мгновенное восстановление без дополнительных запросов
- Формат хранения: развёрнутый, с полными метаданными о связях

**Поведение при запросе:**
- Если человеку задаёшь вопрос, имеющий отношение к чему-то максимально актуальному, он быстро вспоминает в полном объёме, со всеми взаимосвязями
- Система должна воспроизводить это поведение: выдавать полный контекст мгновенно

**Почему 14 дней:**
У большинства людей актуальный отрезок времени — не больше двух недель. Это эмпирическое наблюдение: за это время нерешённые проблемы либо остаются в фокусе, либо решаются и начинают терять актуальность.

### Слой 2: Тёплый (14 дней – 3 месяца)

**Характеристики хранения:**
- Прогрессивная компрессия: плотность упаковки увеличивается со временем
- Частичное сохранение связей — основные остаются, второстепенные теряются
- Воспоминания становятся более фрагментарными

**Оптимизация:**
- Баланс между экономией ресурсов и возможностью восстановления
- Формат хранения: промежуточный, степень сжатия растёт от начала к концу периода

**Поведение при запросе:**
- Если задать вопрос о чём-то, что обсуждали достаточно давно, человек вспоминает дольше и значительно более фрагментарно, с меньшим количеством взаимосвязей
- Система должна сначала выдать то, что есть, а затем при необходимости запустить процесс восстановления

**Динамика компрессии:**
Плотность упаковки не скачкообразная, а градиентная. Информация двухнедельной давности упакована слабо, трёхмесячной — значительно плотнее.

### Слой 3: Холодный (3+ месяцев)

**Характеристики хранения:**
- Стандартный упакованный формат для всех блоков независимо от возраста
- Минимальное семантическое поле: ключевые слова, суть, якоря для поиска
- Связи между блоками минимальны или отсутствуют

**Оптимизация:**
- Цель не в том, чтобы помнить всё детально, а в том, чтобы при необходимости можно было восстановить
- Минимальное контекстное поле служит навигацией: помогает быстро понять «о чём это» и решить, нужно ли копать глубже
- Формат хранения: максимально компактный, унифицированный

**Поведение при запросе:**
- О некоторых вещах человек может помнить только сам факт («да, это было»), но не содержание
- Тем не менее есть обрывки воспоминаний, которые позволяют принять решение: нужно ли восстанавливать подробнее или нет

**Почему после 3 месяцев формат постоянный:**
Все блоки дальнего срока хранятся одинаково, потому что задача у них одна — не детальное воспоминание, а индексация для возможного восстановления. Нет смысла различать то, что было 4 месяца назад, и то, что было 2 года назад — формат хранения один и тот же.

## Механизм работы с памятью

### Алгоритм запроса

**Шаг 1: Поиск в горячем слое**
- Если информация найдена — выдать полный контекст мгновенно
- Это основной сценарий для текущих, актуальных тем

**Шаг 2: Поиск в тёплом слое**
- Если в горячем не найдено или найдено частично
- Выдать то, что есть, с пометкой о неполноте
- Предложить или автоматически запустить восстановление

**Шаг 3: Поиск в холодном слое**
- Сначала выдать только краткую суть: «это было про X, в контексте Y»
- Дождаться сигнала о необходимости глубокой распаковки

### Два сценария распаковки

**Сценарий 1: Поверхностный**

Запрос → поиск в архиве → краткая суть («это примерно про то-то») → этого достаточно → контекст остаётся упакованным.

Пример: в разговоре коснулись темы, которую обсуждали полгода назад. Система выдала краткую суть. Человек понял, о чём речь, но углубляться не нужно. Всё остаётся как было.

**Сценарий 2: Глубокий**

Запрос → поиск в архиве → краткая суть → нужны детали → запуск полного восстановления → распаковка контекста → перенос в горячий слой.

Пример: в разговоре коснулись темы полугодовой давности, и оказалось, что там было что-то важное для текущей задачи. Система восстанавливает полный контекст, и он становится снова актуальным — как будто это обсуждалось только что.

### Ключевой принцип восстановления

Когда человек вспоминает что-то из дальнего прошлого, это происходит только потому, что это вдруг понадобилось сейчас. В процессе вспоминания содержание переносится в настоящий момент — уровень его актуальности и целостности повышается.

Система должна воспроизводить этот механизм: распакованный контекст не просто показывается, а переносится в горячий слой. Он становится «новым», хотя исходная архивная запись может оставаться на месте.

## Миграция между слоями

### Миграция вниз (автоматическая)

**Горячий → Тёплый:**
- Триггер: прошло 14 дней без обращения к блоку
- Действие: начало компрессии, ослабление связей

**Тёплый → Холодный:**
- Триггер: прошло 3 месяца, блок не запрашивался
- Действие: финальная компрессия до стандартного формата

**Важно:** если блок запрашивается в процессе миграции — миграция останавливается или откатывается.

### Миграция вверх (по запросу)

**Холодный → Горячий:**
- Триггер: глубокая распаковка блока
- Действие: полное восстановление контекста, присвоение новой актуальности
- Блок становится «свежим» в горячем слое

**Тёплый → Горячий:**
- Триггер: активное использование блока в текущем разговоре
- Действие: декомпрессия, восстановление связей

### Что происходит с архивной копией

При миграции вверх возникает вопрос: что делать с исходной записью в холодном слое? Варианты:

1. **Удалить** — блок теперь в горячем, дубль не нужен
2. **Оставить** — на случай, если понадобится вернуться к «оригинальной» версии
3. **Пометить как «восстановлен»** — для аналитики и отладки

Это вопрос реализации, но концептуально важно понимать: восстановленный блок — это уже не тот же блок, он обогащён текущим контекстом.

## Аналогия с книгами

Эта аналогия хорошо иллюстрирует принцип работы архитектуры.

**Книга, которую читаю сейчас:**
Помню детально, могу пересказать конкретные моменты, вижу связи между главами и идеями. Это горячий слой.

**Книги двухнедельной–месячной давности:**
Помню хуже, общую канву да, но детали размыты. Это тёплый слой.

**Книги, прочитанные давно:**
О некоторых помню только факт прочтения и смутное ощущение «это было про что-то такое». Это холодный слой.

**Механизм восстановления:**
Если какая-то книга привлекает внимание (понадобилась для текущей задачи), я могу:
- Пролистать — поверхностная распаковка, освежить в памяти суть
- Перечитать целиком — глубокая распаковка, полное восстановление контекста

В зависимости от уровня потребности — разный сценарий. Либо «вспомнил и забыл», либо «восстановил детально и теперь это снова актуально».

## Рациональность архитектуры

Память как алгоритм работает очень рационально. Есть определённые последовательности восстановления блоков информации:
- В первую очередь более полно восстанавливается максимально актуальное
- Во вторую, третью, десятую очередь — менее актуальное

Архитектура хранения подразумевает быстрый одновременный доступ к актуальному, чтобы сразу вытащить весь контекст. Это происходит быстро. Но чем дальше в прошлое, тем архитектура становится более упакованной — нет необходимости хранить всё, достаточно хранить минимальный контекст для навигации и возможного восстановления.

Формат хранения актуального и формат хранения дальнего отличаются, потому что у них разные цели:
- **Актуальное:** цель — сразу восстановить контекст быстро
- **Дальнее:** цель — помочь быстро найти нужные упакованные фрагменты для возможного восстановления

## Практические преимущества

### Экономия ресурсов
Не нужно держать весь контекст в развёрнутом виде. Горячий слой ограничен, тёплый сжат, холодный максимально компактен.

### Релевантность ответов
Приоритет автоматически отдаётся свежему и актуальному. Система не будет вываливать информацию годичной давности с тем же весом, что и вчерашнюю.

### Естественность взаимодействия
Поведение системы похоже на человеческую память. Пользователь интуитивно понимает, почему что-то помнится лучше, а что-то хуже.

### Возможность глубокого восстановления
При этом ничего не теряется навсегда. Если давний контекст понадобился — его можно восстановить и вернуть в актуальное состояние.

## Открытые вопросы для реализации

### Определение актуальности

Как вычислять актуальность блока? Возможные факторы:
- Частота обращений за последний период
- Явные маркеры («это важно», «запомни это»)
- Семантическая близость к текущему разговору
- Связь с нерешёнными проблемами/задачами пользователя

### Алгоритм компрессии

Как именно сжимать информацию при миграции в тёплый и холодный слои:
- Что сохранять, что отбрасывать
- Как сохранять связи в сжатом виде
- Как обеспечить возможность восстановления

### Формат минимального семантического поля

Что должно входить в «упакованный» блок холодного слоя:
- Ключевые слова / теги
- Краткое саммари (сгенерированное при компрессии)
- Якоря для поиска (даты, имена, названия)
- Указатели на связанные блоки

### Триггеры распаковки

Как система решает, когда нужна глубокая распаковка, а когда достаточно поверхностной:
- Явный запрос пользователя («расскажи подробнее»)
- Контекстуальные сигналы (тема развивается, нужны детали)
- Пороговые значения релевантности

### Обработка конфликтов

Что делать, если восстановленный контекст противоречит текущему:
- Информация устарела
- Пользователь изменил мнение/ситуацию
- Как приоритизировать

---

*Документ описывает концептуальную архитектуру. Следующий шаг — детализация каждого компонента и выбор конкретных технических решений для реализации.*