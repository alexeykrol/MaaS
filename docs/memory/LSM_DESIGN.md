# LSM Design: Архитектура долгосрочной памяти

> **Статус:** DEPRECATED — см. [LSM.md](./LSM.md)
>
> Этот документ сохранён для истории. Актуальная спецификация: **[LSM.md](./LSM.md)**

---

> **Статус:** v0.2 — консолидированная версия
> **Принцип:** Анизотропная память — плотность хранения и алгоритмы зависят от временного слоя

---

## 1. Ключевой принцип: Анизотропия

Память **неоднородна**. Качество, скорость доступа и детализация зависят от **актуальности**, а не только от времени.

```
Актуальность = f(Recency, Frequency, Importance, TaskRelevance)
```

Чем выше актуальность — тем выше целостность (больше связей, больше деталей).

---

## 2. Три слоя памяти

### Слой 1: Горячий (Hot) — 0-14 дней

| Параметр | Значение |
|----------|----------|
| **Плотность** | 0% (raw text) |
| **Формат** | Полные логи диалогов |
| **Доступ** | Мгновенный, всегда в контексте |
| **Связи** | Максимальные (scale-free network) |

**Поведение:** Всё помнится детально, "на кончиках пальцев".

### Слой 2: Тёплый (Warm) — 14 дней - 3 месяца

| Параметр | Значение |
|----------|----------|
| **Плотность** | 30-70% (градиент!) |
| **Формат** | Summary + ключевые факты + эмбеддинг |
| **Доступ** | Быстрый поиск по индексу |
| **Связи** | Частичные (основные сохранены) |

**Поведение:** Помнится общая картина, детали размыты. Градиент: 2 недели назад — почти всё помню, 3 месяца — только суть.

### Слой 3: Холодный (Cold) — 3+ месяцев

| Параметр | Значение |
|----------|----------|
| **Плотность** | 90% (стандартный пакет) |
| **Формат** | Минимальное семантическое поле |
| **Доступ** | Только по запросу |
| **Связи** | Минимальные или отсутствуют |

**Поведение:** "Да, это было" — но без деталей. Достаточно для навигации и решения "копать глубже или нет".

---

## 3. Эпизод — атом памяти

Единица хранения — не сообщение, а **эпизод** (связанный блок вокруг одной темы/задачи).

```typescript
interface Episode {
  id: UUID;

  // Временной контекст
  created_at: Timestamp;
  last_accessed: Timestamp;

  // Слой и приоритет
  layer: 'hot' | 'warm' | 'cold';
  priority: number;  // 0.0 - 1.0

  // Семантика (зависит от слоя)
  content: HotContent | WarmContent | ColdContent;

  // Связи
  continues_from: UUID | null;
  related_to: UUID[];

  // Якорь (не теряет приоритет)
  is_anchor: boolean;

  // Ссылка на сырые данные
  raw_log_ids: UUID[];
}
```

### Контент по слоям

```typescript
// Горячий — полный текст
interface HotContent {
  raw_messages: Message[];
  entities: Entity[];
  decisions: Decision[];
}

// Тёплый — сжатый
interface WarmContent {
  summary: string;           // 2-4 предложения
  key_points: string[];      // Буллеты
  entities: Entity[];
  decisions: Decision[];
  embedding: Vector;
}

// Холодный — минимальный
interface ColdContent {
  headline: string;          // 1 предложение "о чём это"
  tags: string[];
  embedding: Vector;
}
```

---

## 4. Алгоритмы саммаризации (разные для каждого перехода!)

### Переход Hot → Warm

**Триггер:** 14 дней без обращения ИЛИ вытеснение из горячего окна.

**Что сохраняем:**
- Ключевые решения и их обоснование
- Извлечённые сущности (проекты, технологии, люди)
- Нерешённые вопросы
- Связи с другими эпизодами

**Что теряем:**
- Промежуточные рассуждения
- Small-talk
- Альтернативы, которые отвергли

**Промпт Архивариуса (Hot→Warm):**
```
Сожми диалог в структурированное резюме.
Сохрани: решения, факты, сущности, открытые вопросы.
Убери: small-talk, промежуточные шаги, отвергнутые варианты.
Формат: summary (2-4 предложения) + key_points (bullets) + entities + decisions.
```

### Переход Warm → Cold

**Триггер:** 3 месяца без обращения.

**Что сохраняем:**
- Суть в одном предложении
- Теги для поиска
- Эмбеддинг

**Что теряем:**
- Детали решений
- Контекст "почему так решили"
- Key points

**Промпт Архивариуса (Warm→Cold):**
```
Сожми до минимума. Одно предложение: о чём был этот эпизод?
Выдели 3-5 тегов для поиска.
Цель: понять "надо ли копать глубже", не более.
```

---

## 5. Алгоритм поиска: Ленивая распаковка

### Шаг 1: Быстрый скан

```
Запрос пользователя
       ↓
Поиск по горячему слою (exact match, full context)
       ↓
Найдено? → Ответ с полным контекстом
       ↓
Не найдено → Поиск по тёплому/холодному (по эмбеддингам)
```

### Шаг 2: Оценка глубины

```
Найден релевантный эпизод в архиве
       ↓
Analyzer решает: "Достаточно ли summary?"
       ↓
┌──────┴──────┐
↓             ↓
ДА            НЕТ
↓             ↓
Ответ по      Запуск
summary       распаковки
```

### Шаг 3: Распаковка и реактуализация

```
Нужна полная информация
       ↓
Загрузить raw_logs из холодного хранилища
       ↓
Восстановить полный контекст
       ↓
ПЕРЕНЕСТИ эпизод в горячий слой (реактуализация!)
       ↓
Ответить с полным контекстом
```

**Ключевое:** После распаковки эпизод становится "свежим" — его приоритет обновляется, он снова в горячем слое.

---

## 6. Миграция между слоями

### Вниз (автоматическая, по времени)

```
Hot → Warm: 14 дней без обращения
Warm → Cold: 3 месяца без обращения
```

При миграции вниз запускается соответствующий алгоритм саммаризации.

### Вверх (по запросу, реактуализация)

```
Cold → Hot: глубокая распаковка по запросу
Warm → Hot: активное использование в текущем разговоре
```

При миграции вверх:
- Загружаются raw_logs (если есть)
- Восстанавливается полный контекст
- Обновляется приоритет и last_accessed

---

## 7. Якоря (Anchors)

Некоторые эпизоды не должны терять приоритет:
- Профиль пользователя
- Долгосрочные проекты
- Явно помеченные ("запомни это навсегда")
- Системные инструкции

```typescript
if (episode.is_anchor) {
  episode.priority = Math.max(episode.priority, ANCHOR_MIN_PRIORITY);
  // Никогда не мигрирует в холодный слой
}
```

---

## 8. Приоритет: формула

```typescript
function calculatePriority(episode: Episode): number {
  const recency = decay(daysSince(episode.last_accessed));  // 0-0.3
  const frequency = normalize(episode.access_count);         // 0-0.2
  const importance = episode.is_anchor ? 0.3 : 0;            // 0 или 0.3
  const relevance = cosineSimilarity(episode.embedding, currentQueryEmbedding); // 0-0.2

  return recency + frequency + importance + relevance;
}
```

Пороги миграции:
- `P > 0.7` → Горячий
- `0.3 < P ≤ 0.7` → Тёплый
- `P ≤ 0.3` → Холодный

---

## 9. Что меняется в MaaS

### Было (плоская LSM)
```sql
lsm_storage: id, time_bucket, tags, summary, raw_log_ids
```

### Стало (слоистая LSM)
```sql
episodes:
  id, layer, priority, is_anchor,
  created_at, last_accessed, access_count,
  content_hot JSONB,    -- для hot слоя
  content_warm JSONB,   -- для warm слоя
  content_cold JSONB,   -- для cold слоя
  embedding VECTOR,
  continues_from UUID,
  related_to UUID[],
  raw_log_ids UUID[]
```

Или три таблицы: `episodes_hot`, `episodes_warm`, `episodes_cold`.

---

## 10. Алгоритм упаковки

> **См. отдельный документ:** [PACKING.md](./PACKING.md)

Упаковка (саммаризация) — это отдельный инфраструктурный алгоритм, который:
- Используется при переходах Hot→Warm→Cold
- Имеет свой пайплайн и метрики
- Итерируется через Self-Learning

---

## 11. Открытые вопросы

1. **Границы эпизода:** Как определить, что началась новая тема?
2. **Конфликты:** Если старое противоречит новому — как приоритизировать?
3. **Размер горячего окна:** Фиксированный (14 дней) или адаптивный (N токенов)?
4. **Хранение raw_logs:** Сколько хранить? Когда удалять?

---

*Версия: 0.2*
*Дата: 2025-11-29*
*Источники: исходная архитектура + консультации с ChatGPT, Claude, Gemini, Grok*
