# USER EMULATOR — архитектура модуля эмуляции пользователя

## 0. Зачем нужен эмулятор пользователя

Эмулятор решает фундаментальную проблему: **реальные диалоги — единственный надёжный источник обучения для MaaS**, но их всегда мало, они нерегулярны и не покрывают нужные категории. Без эмулятора система учится медленно, хаотично и на несбалансированных данных.

Эмулятор нужен для:

1. **Создания реалистичных обучающих диалогов**
   Он имитирует реальные проекты, цели и поведение людей. Это формирует обучающие кейсы, которые воспроизводят настоящие пользовательские задачи.

2. **Тестирования системы под нагрузкой и в вариативных сценариях**
   Можно запускать десятки параллельных thread, моделируя разное поведение пользователей — от новичков до экспертов.

3. **Оценки качества в динамике**
   Только через цепочки вопросов видно, как система держит контекст, как она развивает мысль, насколько стабильно ведёт диалог.

4. **Управляемого самообучения**
   Эмулятор генерирует новые ситуации → учитель анализирует → параметры системы корректируются → повтор цикла.

5. **Безопасной проверки гипотез**
   Перед тем как менять импакт‑факторы для реальных пользователей, мы проверяем, что новая настройка работает осязаемо лучше.

6. **Широкого покрытия**
   Эмулятор позволяет тестировать категории вопросов и стилей поведения, которые редко встречаются в реальной жизни, но важны для качества.

В итоге эмулятор — это способ превратить MaaS из статической системы в **самообучающийся организм**, который постоянно улучшает своё поведение без вмешательства реального пользователя.

## 1. Роль эмулятора

**Эмулятор пользователя** — это автономный модуль, который:

* ведёт себя как реальный пользователь;
* инициирует и поддерживает полноценные диалоги с ассистентом (MaaS);
* генерирует не одиночные вопросы, а логически связанные **цепочки запросов**;
* использует MaaS строго как внешний клиент, без доступа к внутренностям.

Цель: создавать реалистичные сценарии взаимодействия, чтобы система могла обучаться на реальных диалогах, а не на искусственных одиночных запросах.

---

## 2. Компоненты эмулятора

### 2.1. Scenario / Persona Generator

**Артефакты:**

* `sim_scenarios.json` — набор сценариев/проектов.
* `sim_personas.json` — профили синтетических пользователей.

**Задачи генератора:**

* определить тему проекта (project);
* задать намерение пользователя (intent);
* наложить ограничения (уровень знаний, стиль речи, терпимость к сложности);
* сформировать **описание кейса**, которое станет основой одного thread.

---

### 2.2. Simulated User State

**Артефакт:** структура `SimUserState` (опционально логгируется в `sim_sessions`).

**Что хранит:**

* цель сценария;
* историю диалога;
* понимание того, что уже ответил ассистент;
* список заданных вопросов;
* список неразрешённых/непонятных пунктов.

Это внутреннее состояние пользователя, которое позволяет генерировать осмысленную цепочку вопросов.

---

### 2.3. Dialogue Policy (User Emulator Policy)

**Артефакты:**

* `sim_user_policy_prompt.md` — стратегия поведения пользователя;
* `sim_user_policy_config` — параметры (макс. длина диалога, стиль вопросов, порог раздражения и т.п.).

**Что делает Dialogue Policy:**

* принимает на вход: `SimUserState`, ответ MaaS и сценарий;
* генерирует следующий **user message**, который может быть:

  * уточняющим вопросом,
  * сменой фокуса,
  * просьбой объяснить проще,
  * фиксацией промежуточного вывода.

По сути — это LLM, играющий роль пользователя с заданной стратегией поведения.

---

### 2.4. Интерфейс к MaaS (Sim Runner)

**Артефакт:** `sim_runner.ts`

**Задачи:**

* отправляет сгенерированный user message в реальный MaaS;
* получает ответ ассистента;
* логирует пайплайн в Telemetry;
* обновляет `SimUserState`;
* решает, завершать ли сценарий или продолжать.

Sim Runner может запускать десятки thread’ов параллельно.

---

## 3. Жизненный цикл одного thread

### 3.1. Инициализация

* Scenario Generator создаёт тему, цель и persona.
* Формируется `SimUserState`.

Пример:

* Тема: переход в data science.
* Цель: получить план на 3 месяца.
* Persona: 40 лет, низкий техбэкграунд.

---

### 3.2. Первый запрос

Dialogue Policy генерирует стартовый вопрос на основе сценария и пустого состояния.

Пример:

> «Я хочу уйти из маркетинга и перейти в data science. С чего начать?»

Sim Runner отправляет его в реальный MaaS.

---

### 3.3. Ответ MaaS

MaaS проходит через обычный пайплайн:

* retrieval → память → финальный ответ.

Ответ логируется в Telemetry.

---

### 3.4. Обновление состояния

Sim Runner обновляет `SimUserState`:

* какие пункты покрыты;
* какие остались непонятными;
* какие уточнения нужны.

---

### 3.5. Следующий ход

Policy анализирует:

* прогресс относительно цели;
* пробелы в ответе;
* стиль поведения пользователя.

Генерирует новый запрос.

Пример:

> «Можешь уточнить, какие именно курсы по статистике мне нужны?»

---

### 3.6. Цикл

Диалог продолжается до:

* достижения цели;
* исчерпания лимита шагов;
* моделируемой «усталости/раздражения».

---

### 3.7. Завершение

Сохраняются:

* последовательность запросов и ответов;
* метрики из Telemetry;
* итоговый вердикт от Teacher/LLM-judge.

Это становится учебным примером (experience).

---

## 4. Взаимодействие эмулятора с MaaS

Эмулятор **не использует внутренние API**, а работает как внешний пользователь.

Путь запроса:

1. Эмулятор генерирует обычный `user_message`.
2. MaaS обрабатывает его полностью как обычный запрос.
3. Все pipeline_runs и telemetry_events записываются в те же таблицы.

Эмулятор — это просто ещё один тип клиента.

---

## 5. Роль учителя (Evaluator + Optimizer)

Эмулятор не оценивает и не улучшает систему.
Он только **создаёт опыт (experience)**.

Учитель:

* анализирует логи и метрики;
* использует LLM-judge для оценки качества;
* принимает решения об изменении импакт-факторов:

  * `top_k`,
  * `recency_weight`,
  * изменения system prompt.

Ученик = MaaS + текущие настройки.
Эмулятор = пользователь.
Учитель = анализ и корректировка.

---

## 6. Риски и слабые места

### 6.1. Self-licking ice cream cone

Может возникнуть переобучение на поведение симулятора.
Нужно периодически сверять сценарии с реальными пользователями.

---

### 6.2. Слишком «умный» симулятор

Если Policy будет адаптивным, он может подстраиваться под слабые ответы MaaS и улучшать их за счёт собственных переформулировок.

Это скрывает реальные ошибки системы.

---

### 6.3. Узкое распределение сценариев

Если сценарии однообразны, MaaS переобучится на один тип запроса.

Решение:

* регистр разнообразных сценариев;
* контроль покрытия категорий (как в Golden Dataset).

---

Готово — документ полностью перенесён в канвас в структурированном виде.
