# USER EMULATOR — архитектура модуля эмуляции пользователя

## 0. Ключевая концепция (обновлено 2025-11-27)

> **MaaS — это middleware, который превращает простого ассистента в Агента с памятью.**

### Что такое MaaS

```
┌─────────────────────────────────────────────────────────────────────────┐
│                                                                          │
│   Клиент              MaaS (middleware)              Ассистент          │
│   (вопрошающий)       ┌──────────────────┐          (отвечающая         │
│                       │                  │           модель)            │
│        │              │  ┌────────────┐  │              │               │
│        │──────────────┼─►│ Analyzer   │  │              │               │
│        │              │  └─────┬──────┘  │              │               │
│        │              │        │         │              │               │
│        │              │        ▼         │              │               │
│        │              │  ┌────────────┐  │              │               │
│        │              │  │    LSM     │  │              │               │
│        │              │  │  (память)  │  │              │               │
│        │              │  └─────┬──────┘  │              │               │
│        │              │        │         │              │               │
│        │              │        ▼         │              │               │
│        │              │  ┌────────────┐  │   context    │               │
│        │              │  │ Assembler  │──┼─────────────►│               │
│        │              │  └────────────┘  │              │               │
│        │              │                  │              │               │
│        │◄─────────────┼──────────────────┼──────────────│               │
│        │              │        ▲         │    ответ     │               │
│        │              │  ┌─────┴──────┐  │              │               │
│        │              │  │ Archivist  │◄─┼──────────────│               │
│        │              │  └────────────┘  │              │               │
│        │              │                  │              │               │
│        │              └──────────────────┘              │               │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘

Без MaaS: Клиент ──────────────► Ассистент ──────────────► Клиент
                   (напрямую, без памяти)
```

**Ключевое:**
- Клиент (вопрошающий) — **вне** MaaS
- Ассистент (отвечающая модель) — **вне** MaaS
- MaaS — **между ними**, добавляет память

### Архитектура эмулятора: два агента с памятью

**Агент = Клиент + MaaS + Ассистент**

```
┌────────────────────────────────────────────────────────────────┐
│                    Диалог двух агентов                         │
│                                                                │
│   Agent A (Ученик)                  Agent B (Учитель)          │
│   ┌──────────────────┐              ┌──────────────────┐       │
│   │ meta-prompt:     │              │ meta-prompt:     │       │
│   │ "изучаешь тему"  │              │ "объясняешь тему"│       │
│   └────────┬─────────┘              └────────┬─────────┘       │
│            │                                 │                 │
│            ▼                                 ▼                 │
│   ┌──────────────────┐              ┌──────────────────┐       │
│   │      MaaS        │◄────────────►│      MaaS        │       │
│   │   (middleware)   │   диалог     │   (middleware)   │       │
│   └────────┬─────────┘              └────────┬─────────┘       │
│            │                                 │                 │
│            ▼                                 ▼                 │
│   ┌──────────────────┐              ┌──────────────────┐       │
│   │  LSM (user_id=A) │              │  LSM (user_id=B) │       │
│   │  "я спрашивал X" │              │  "он спрашивал X"│       │
│   └──────────────────┘              └──────────────────┘       │
│                                                                │
└───────────────────────────┬────────────────────────────────────┘
                            │
                            ▼
                   ┌─────────────────┐
                   │  Self-Learning  │
                   │                 │
                   │  Оценивает:     │
                   │  - память A     │
                   │  - память B     │
                   │  - качество     │
                   └─────────────────┘
```

### Ключевые принципы

1. **MaaS = middleware** — добавляет память к любому ассистенту
2. **Агент = Клиент + MaaS + Ассистент** — полная связка
3. **Оба агента накапливают память** — Ученик помнит что спрашивал, Учитель помнит что отвечал
4. **Разница только в meta-prompt** — он определяет роль (Ученик/Учитель)
5. **Self-Learning оценивает обоих** — фокус на качестве памяти
6. **Симуляция времени** — имитируем timestamps для тестирования памяти за месяцы/годы

### Что тестируем

| Аспект | Проверка |
|--------|----------|
| **Recall** | Помнит ли агент что было в прошлых тредах? |
| **Precision** | Поднимает ли релевантную память, а не шум? |
| **Temporal** | Работает ли память через "месяц", "год"? |
| **Cross-thread** | Помнит ли агент между разными тредами? |

### Цель

> Оценить эффективность **архитектуры памяти** и **impact factors** для полноценной памяти агента.

---

## 0.1. Зачем нужен эмулятор пользователя

Эмулятор решает фундаментальную проблему: **реальные диалоги — единственный надёжный источник обучения для MaaS**, но их всегда мало, они нерегулярны и не покрывают нужные категории. Без эмулятора система учится медленно, хаотично и на несбалансированных данных.

Эмулятор нужен для:

1. **Создания реалистичных обучающих диалогов**
   Он имитирует реальные проекты, цели и поведение людей. Это формирует обучающие кейсы, которые воспроизводят настоящие пользовательские задачи.

2. **Тестирования системы под нагрузкой и в вариативных сценариях**
   Можно запускать десятки параллельных thread, моделируя разное поведение пользователей — от новичков до экспертов.

3. **Оценки качества в динамике**
   Только через цепочки вопросов видно, как система держит контекст, как она развивает мысль, насколько стабильно ведёт диалог.

4. **Управляемого самообучения**
   Эмулятор генерирует новые ситуации → учитель анализирует → параметры системы корректируются → повтор цикла.

5. **Безопасной проверки гипотез**
   Перед тем как менять импакт‑факторы для реальных пользователей, мы проверяем, что новая настройка работает осязаемо лучше.

6. **Широкого покрытия**
   Эмулятор позволяет тестировать категории вопросов и стилей поведения, которые редко встречаются в реальной жизни, но важны для качества.

В итоге эмулятор — это способ превратить MaaS из статической системы в **самообучающийся организм**, который постоянно улучшает своё поведение без вмешательства реального пользователя.

## 1. Роль эмулятора

**Эмулятор пользователя** — это автономный модуль, который:

* ведёт себя как реальный пользователь;
* инициирует и поддерживает полноценные диалоги с ассистентом (MaaS);
* генерирует не одиночные вопросы, а логически связанные **цепочки запросов**;
* использует MaaS строго как внешний клиент, без доступа к внутренностям.

Цель: создавать реалистичные сценарии взаимодействия, чтобы система могла обучаться на реальных диалогах, а не на искусственных одиночных запросах.

---

## 2. Компоненты эмулятора

### 2.1. Scenario / Persona Generator

**Артефакты:**

* `sim_scenarios.json` — набор сценариев/проектов.
* `sim_personas.json` — профили синтетических пользователей.

**Задачи генератора:**

* определить тему проекта (project);
* задать намерение пользователя (intent);
* наложить ограничения (уровень знаний, стиль речи, терпимость к сложности);
* сформировать **описание кейса**, которое станет основой одного thread.

---

### 2.2. Simulated User State

**Артефакт:** структура `SimUserState` (опционально логгируется в `sim_sessions`).

**Что хранит:**

* цель сценария;
* историю диалога;
* понимание того, что уже ответил ассистент;
* список заданных вопросов;
* список неразрешённых/непонятных пунктов.

Это внутреннее состояние пользователя, которое позволяет генерировать осмысленную цепочку вопросов.

---

### 2.3. Dialogue Policy (User Emulator Policy)

**Артефакты:**

* `sim_user_policy_prompt.md` — стратегия поведения пользователя;
* `sim_user_policy_config` — параметры (макс. длина диалога, стиль вопросов, порог раздражения и т.п.).

**Что делает Dialogue Policy:**

* принимает на вход: `SimUserState`, ответ MaaS и сценарий;
* генерирует следующий **user message**, который может быть:

  * уточняющим вопросом,
  * сменой фокуса,
  * просьбой объяснить проще,
  * фиксацией промежуточного вывода.

По сути — это LLM, играющий роль пользователя с заданной стратегией поведения.

---

### 2.4. Интерфейс к MaaS (Sim Runner)

**Артефакт:** `sim_runner.ts`

**Задачи:**

* отправляет сгенерированный user message в реальный MaaS;
* получает ответ ассистента;
* логирует пайплайн в Telemetry;
* обновляет `SimUserState`;
* решает, завершать ли сценарий или продолжать.

Sim Runner может запускать десятки thread’ов параллельно.

---

## 3. Жизненный цикл одного thread

### 3.1. Инициализация

* Scenario Generator создаёт тему, цель и persona.
* Формируется `SimUserState`.

Пример:

* Тема: переход в data science.
* Цель: получить план на 3 месяца.
* Persona: 40 лет, низкий техбэкграунд.

---

### 3.2. Первый запрос

Dialogue Policy генерирует стартовый вопрос на основе сценария и пустого состояния.

Пример:

> «Я хочу уйти из маркетинга и перейти в data science. С чего начать?»

Sim Runner отправляет его в реальный MaaS.

---

### 3.3. Ответ MaaS

MaaS проходит через обычный пайплайн:

* retrieval → память → финальный ответ.

Ответ логируется в Telemetry.

---

### 3.4. Обновление состояния

Sim Runner обновляет `SimUserState`:

* какие пункты покрыты;
* какие остались непонятными;
* какие уточнения нужны.

---

### 3.5. Следующий ход

Policy анализирует:

* прогресс относительно цели;
* пробелы в ответе;
* стиль поведения пользователя.

Генерирует новый запрос.

Пример:

> «Можешь уточнить, какие именно курсы по статистике мне нужны?»

---

### 3.6. Цикл

Диалог продолжается до:

* достижения цели;
* исчерпания лимита шагов;
* моделируемой «усталости/раздражения».

---

### 3.7. Завершение

Сохраняются:

* последовательность запросов и ответов;
* метрики из Telemetry;
* итоговый вердикт от Teacher/LLM-judge.

Это становится учебным примером (experience).

---

## 3.8. Симуляция времени (Temporal Testing)

> **Цель:** проверить работу памяти на длительных периодах (месяцы, годы) без реального ожидания.

### Как работает

Эмулятор создаёт **несколько тредов с имитированными timestamps**:

```
Thread 1 (simulated: Jan 1)
├── Inference 1: "Я изучаю Python"
├── Inference 2: "Какие библиотеки для ML?"
└── Inference 3: → память: [python, ml, начало_обучения]

Thread 2 (simulated: Jan 15)  ← "через 2 недели"
├── Inference 1: "Продолжаю изучать..."
├── Inference 2: "Помнишь, я спрашивал про ML?"
└── Проверка: поднялась ли память из Thread 1?

Thread 3 (simulated: Feb 1)  ← "через месяц"
├── Inference 1: "Как мои успехи с Python?"
└── Проверка: помнит ли агент начало обучения?

Thread 4 (simulated: Dec 1)  ← "через год"
├── Inference 1: "Помнишь, год назад я начал учить Python?"
└── Проверка: работает ли долгосрочная память?
```

### Что тестируем

| Период | Проверка |
|--------|----------|
| Часы | Краткосрочная память в рамках треда |
| Дни | Память между тредами |
| Недели | Консолидация памяти |
| Месяцы | Долгосрочное хранение |
| Год+ | Архивная память, decay |

### Реализация

```typescript
// Симуляция timestamp при создании pipeline_run
await createPipelineRun({
  user_id: agentId,
  user_query: query,
  created_at: simulatedTimestamp,  // ← имитация времени
  metadata: { simulated: true }
});
```

### Метрики temporal testing

- **Temporal Recall** — % памяти, найденной через N дней/месяцев
- **Memory Decay** — как ухудшается recall со временем
- **Cross-thread Precision** — релевантность памяти из других тредов

---

## 3.9. Целенаправленный диалог (Goal-Oriented Dialogue)

> **Принцип:** Каждый эмулированный диалог — это проект с конкретной целью, а не casual chat.

### Почему это важно

Бессмысленные диалоги ("привет", "как дела") не дают информации о качестве памяти. Чтобы проверить, что память работает, нужен **контекст, который можно вспомнить**.

```
❌ Плохо (casual chat):
   User: "Привет!"
   Assistant: "Привет! Чем могу помочь?"
   User: "Как погода?"
   → Нечего запоминать, нечего проверять

✅ Хорошо (goal-oriented):
   User: "Я хочу выучить Python за 3 месяца"
   Assistant: "Отлично! Какой у тебя бэкграунд?"
   User: "Я маркетолог, 40 лет, программирования не знаю"
   → Цель + контекст + факты для запоминания
```

### Структура проекта

Каждый эмулированный диалог = **проект** с:

| Элемент | Пример |
|---------|--------|
| **Цель** | Выучить Python для data science |
| **Временной горизонт** | 3 месяца |
| **Контекст** | Маркетолог 40 лет, нет опыта в коде |
| **Метрики успеха** | Написать первый ML-проект |
| **Milestones** | Неделя 1: синтаксис, Неделя 2: pandas... |

### Meta-Prompt как определитель роли

Разница между Учеником и Учителем — **только в meta-prompt**:

```markdown
# Meta-Prompt для Ученика (Student)

## Твоя роль
Ты — человек, который хочет достичь цели. Ты задаёшь вопросы,
уточняешь непонятное, возвращаешься к темам.

## Твой проект
- Цель: {goal}
- Контекст: {persona_context}
- Что ты уже знаешь: {existing_knowledge}

## Твоё поведение
- Задавай уточняющие вопросы
- Возвращайся к прошлым темам
- Проверяй, помнит ли собеседник твой контекст
```

```markdown
# Meta-Prompt для Учителя (Teacher)

## Твоя роль
Ты — эксперт, который помогает достичь цели. Ты объясняешь,
структурируешь знания, отслеживаешь прогресс.

## Твоя миссия
- Помочь ученику достичь: {goal}
- Учитывать контекст: {student_context}
- Адаптировать сложность под уровень

## Твоё поведение
- Давай структурированные ответы
- Ссылайся на прошлые темы
- Используй память о контексте ученика
```

### Что это даёт для тестирования памяти

| Аспект | Как проверяется |
|--------|-----------------|
| **Recall** | "Помнишь, я говорил про X?" — агент должен найти X |
| **Precision** | При вопросе о Python не должен поднимать память о кулинарии |
| **Context** | "Какой у меня бэкграунд?" — должен помнить persona |
| **Progress** | "Что я уже изучил?" — должен знать milestones |
| **Goals** | "Какая у меня цель?" — должен помнить исходную задачу |

### Пример полного цикла

```
Проект: "Изучение Python для Data Science"
Persona: Маркетолог 40 лет, цель — сменить профессию

Thread 1 (simulated: Jan 1):
  User: "Хочу уйти из маркетинга в data science. С чего начать?"
  → Memory: [цель: data science, контекст: маркетолог, старт: январь]

Thread 2 (simulated: Jan 15):
  User: "Как продвигается мой план?"
  → Проверка: помнит ли агент цель и контекст?

Thread 3 (simulated: Feb 1):
  User: "Я прошёл курс по Python. Что дальше?"
  → Memory: [прогресс: Python done, следующий шаг: pandas]

Thread 4 (simulated: Mar 1):
  User: "Напомни, какой у меня был план на 3 месяца?"
  → Проверка: помнит ли агент весь путь от начала?
```

### Масштабирование ролей

Meta-prompt как impact factor позволяет легко добавлять новые роли:

| Роль | Meta-Prompt определяет |
|------|------------------------|
| **Student** | Задаёт вопросы, имеет цель, проверяет память |
| **Teacher** | Объясняет, помнит контекст ученика |
| **Mentor** | Даёт советы, отслеживает долгосрочный прогресс |
| **Coach** | Мотивирует, помнит успехи и неудачи |
| **Peer** | Обсуждает на равных, обменивается опытом |

Все роли используют одну архитектуру MaaS — разница только в промпте.

---

## 4. Взаимодействие эмулятора с MaaS

Эмулятор **не использует внутренние API**, а работает как внешний пользователь.

Путь запроса:

1. Эмулятор генерирует обычный `user_message`.
2. MaaS обрабатывает его полностью как обычный запрос.
3. Все pipeline_runs и telemetry_events записываются в те же таблицы.

Эмулятор — это просто ещё один тип клиента.

---

## 5. Роль учителя (Evaluator + Optimizer)

Эмулятор не оценивает и не улучшает систему.
Он только **создаёт опыт (experience)**.

Учитель:

* анализирует логи и метрики;
* использует LLM-judge для оценки качества;
* принимает решения об изменении импакт-факторов:

  * `top_k`,
  * `recency_weight`,
  * изменения system prompt.

Ученик = MaaS + текущие настройки.
Эмулятор = пользователь.
Учитель = анализ и корректировка.

---

## 6. Риски и слабые места

### 6.1. Self-licking ice cream cone

Может возникнуть переобучение на поведение симулятора.
Нужно периодически сверять сценарии с реальными пользователями.

---

### 6.2. Слишком «умный» симулятор

Если Policy будет адаптивным, он может подстраиваться под слабые ответы MaaS и улучшать их за счёт собственных переформулировок.

Это скрывает реальные ошибки системы.

---

### 6.3. Узкое распределение сценариев

Если сценарии однообразны, MaaS переобучится на один тип запроса.

Решение:

* регистр разнообразных сценариев;
* контроль покрытия категорий (как в Golden Dataset).

---

Готово — документ полностью перенесён в канвас в структурированном виде.
