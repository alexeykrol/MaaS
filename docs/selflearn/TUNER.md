Опишу Настройщика как модуль, а не как «роль в голове».

---

## 1. Кто такой Настройщик

**Настройщик (Tuner)** — это *чистый технический сервис* без LLM, который:

* принимает решения Учителя и/или Менеджера **в структурированном виде**;
* проверяет, что эти решения не нарушают политики и диапазоны;
* создаёт/активирует/откатывает версии параметров MaaS;
* обеспечивает трассируемость: кто, что, когда и почему поменял.

Важно: Настройщик **ничего сам не придумывает**.
Это «руки системы», а не «мозги».

---

## 2. Задачи Настройщика по пунктам

### 2.1. Применение изменений параметров

Минимальный контракт:

* принять список изменений:

  ```json
  {
    "changes": [
      { "param": "retrieval.top_k", "from": 3, "to": 2 },
      { "param": "llm.temperature", "from": 0.7, "to": 0.5 }
    ],
    "reason": "experiment: top_k_3_vs_2",
    "initiator": "teacher",
    "experiment_id": "top_k_3_vs_2"
  }
  ```

* проверить, что:

  * эти параметры существуют,
  * типы значений корректны,
  * значения попадают в разрешённые диапазоны;

* создать **новую версию конфигурации** в `experiment_parameters`;

* сделать её активной (или привязанной к конкретному эксперименту);

* залогировать факт изменения.

### 2.2. Подготовка экспериментальных вариантов

Поддержка команд вида `prepare_experiment`:

* на вход:

  * `experiment_id`;
  * список variant’ов с набором параметров;
* на выход:

  * записи в `experiment_parameters` / `experiment_variants`, связанные с `experiment_id`;
  * конфиг, который могут использовать:

    * Sim Runner (чтобы знать, с какими параметрами гонять диалоги),
    * MaaS (чтобы подхватывать правильный набор параметров для данного `variant`).

Настройщик **не решает**, какие параметры варьировать — только создаёт и хранит их версии.

### 2.3. Активация и откат версий

Функции:

* `activate_parameter_version(version_id | version_number)`

  * деактивировать текущую активную версию;
  * активировать заданную;
  * убедиться, что ровно одна активная версия для prod.
* `rollback_parameters()`

  * найти предыдущую стабильную версию;
  * переключиться на неё;
  * залогировать причину (например, «degradation: hallucination_rate +8%»).

Инициаторами активации/отката могут быть:

* Учитель (по результатам эксперимента);
* Менеджер (ручное управление через фронт);
* Auto-rollback правила (которые формально приходят от Учителя в виде команды).

### 2.4. Применение guard-политик (safety)

Настройщик отвечает за то, чтобы **физически невозможно** было:

* выставить значение параметра вне допустимого диапазона;
* изменить параметры, помеченные как «manual-only» (например, смена модели, RLS, pgvector);
* обойти ограничения, заданные Мета-пользователем через Менеджера.

Примеры правил:

* `top_k` ∈ [1, 5];
* `temperature` ∈ [0.0, 1.0], но авто-тюнинг ∈ [0.5, 0.9];
* `model` ∈ { "gpt-4o-mini", "gpt-4o" }, но `model` изменяется только по прямой команде от Менеджера с флагом `manual_approval`.

Если приходящее изменение нарушает guard — Настройщик:

* его отклоняет;
* пишет в лог причину и инициатора;
* при необходимости шлёт алерт Менеджеру.

### 2.5. Экспорт «эффективных параметров» для рантайма

MaaS и Sim Runner должны получать **готовый набор параметров**, а не собирать его сами из кучи таблиц.

Задача Настройщика:

* по запросу `get_effective_params(context)` вернуть:

  ```json
  {
    "retrieval": { "top_k": 2, "relevance_weight": 0.6, ... },
    "llm": { "model": "gpt-4o-mini", "temperature": 0.5 },
    "context": { "max_tokens": 4000 },
    ...
  }
  ```

* контекст может включать:

  * обычный prod-запрос (без эксперимента);
  * запрос в рамках эксперимента (`experiment_id`, `variant`);
  * tenant/namespace (для будущей мульти-аренды).

Так рантайм остаётся простым: он не знает про версийность и политику — только спрашивает «дай мне актуальные параметры».

### 2.6. Аудит и история изменений

Настройщик — точка, где **все настройки проходят через один вход**, поэтому он же:

* пишет в change-log:

  * кто инициировал (`teacher` / `manager` / `auto-rollback`);
  * контекст (`experiment_id`, ссылка на отчёт Учителя, ручной комментарий);
  * diff параметров;
  * timestamp;
* предоставляет интерфейс для просмотра истории:

  * «как менялся `top_k` за последний месяц»;
  * «какая конфигурация была активна в момент эксперимента X»;
  * «кто включил `pgvector` и когда».

---

## 3. Интерфейсы Настройщика

### 3.1. Входные каналы

1. **От Учителя:**

   * `prepare_experiment`
   * `update_params` (по результатам экспериментов)
   * `rollback_by_reason` (деградация, нарушения)

2. **От Менеджера / фронта:**

   * ручные изменения в «manual-only» зоне;
   * изменение границ диапазонов (политики);
   * freeze/unfreeze авто-тюнинга.

3. **От систем мониторинга:**

   * триггеры типа `auto_rollback_required` (по готовому вердикту от Учителя или внешнего мониторинга).

### 3.2. Выходные каналы

1. **В MaaS / Sim Runner:**

   * `get_effective_params(context)` — выдача готовых параметров.
2. **В Telemetry / журнал:**

   * события `param_version_created`, `param_version_activated`, `rollback_performed`, `change_rejected`.
3. **В Менеджера:**

   * статусы операций (успешно / отклонено с причиной);
   * агрегированная статистика по изменениям (для отчётов).

---

## 4. Внутренняя структура Настройщика (как модуля)

Можно разложить на несколько подмодулей:

1. **API-слой / Adapter**

   * принимает запросы в виде JSON / команд от других ролей;
   * валидирует схему (JSON Schema / TypeScript types);
   * мапит на внутренние команды.

2. **Guard Engine (Policy Checker)**

   * проверяет:

     * допустимость параметра;
     * диапазоны;
     * «manual-only» флаги;
     * текущие глобальные политики от Мета-пользователя.
   * возвращает либо `ok`, либо явную ошибку: `OUT_OF_RANGE`, `FORBIDDEN_PARAM`, `MANUAL_ONLY`, etc.

3. **Versioning Engine**

   * работает с таблицей `experiment_parameters` (и, возможно, вспомогательными таблицами);
   * умеет:

     * создавать новую версию;
     * помечать её активной/экспериментальной;
     * находить предыдущую стабильную версию;
     * обеспечивать инвариант: ровно одна активная prod-версия.

4. **Runtime Resolver**

   * по `context` (prod / experiment / tenant) собирает финальный объект параметров;
   * кеширует его (если надо) для ускорения.

5. **Audit & Logging**

   * все изменения проходят через один узел логирования;
   * обеспечивает трассируемость для отладки и для тебя как Мета-пользователя.

---

## 5. Границы ответственности и «не-цели»

### 5.1. Чего Настройщик НЕ делает

* не считает метрики;
* не решает, *надо ли* менять параметр;
* не проектирует эксперименты;
* не общается с пользователями;
* не использует LLM.

Если в коде Настройщика появляется «умная логика» выбора конфигураций — это уже утечка ответственности из Учителя / Менеджера.

### 5.2. Когда он может «отказать»

Настройщик должен иметь право отказать даже Учителю, если:

* запрос нарушает жёсткие политики Мета-пользователя;
* выход за допустимые диапазоны;
* множатся конфликты версий (например, две активные версии одновременно);
* попытка обойти manual-only ограничения.

---

## 6. Риски и слабые места (по-скептически)

1. **Слот для «грязной логики»**

   * Есть риск, что разработчики начнут подсовывать в Настройщик куски «умных» решений, потому что «здесь и так все параметры».
   * Лекарство: жёстко прописанный контракт — только валидация, версионирование, применение, audit.

2. **Единая точка отказа**

   * Если Настройщик падает или блокируется, система не может менять параметры.
   * Нужно:

     * чётко разделять «читать эффективные параметры» и «менять версии»;
     * делать чтение максимально надёжным и простым.

3. **Сложность миграций**

   * При добавлении новых параметров/структур понадобятся миграции схемы `experiment_parameters`.
   * Нужно:

     * предусмотреть JSONB-поля + минимальный набор колонок;
     * деплоить миграции так, чтобы не ломать `get_effective_params`.

---

## 7. Что потом можно прямо отдавать на разработку

Из этого описания можно собрать техзадание:

* описать API Настройщика:

  * эндпоинты / функции: `prepare_experiment`, `update_params`, `activate_version`, `rollback`, `get_effective_params`;
  * структура входных/выходных DTO;
* описать схему БД:

  * `experiment_parameters` + возможно `parameter_changes_log`;
* описать набор guard-правил:

  * список параметров, диапазоны, manual-only флаги;
* описать интеграцию:

  * кто вызывает Настройщика (Учитель, Менеджер, рантайм MaaS);
  * как он логирует изменения.

Если нужно, следующим шагом могу выдать прям скелет `TUNER_SPEC.md` с таблицами:
**Артефакты → API → БД → Инварианты → Сценарии использования → Ошибки.**
